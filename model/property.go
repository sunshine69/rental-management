// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"context"
	u "github.com/sunshine69/golang-tools/utils"
	"strings"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type Property struct {
	Id            int64          `db:"id"`
	Code          string         `db:"code,unique"`
	Address       string         `db:"address"`
	Note          string         `db:"note" form:"Note,ele=textarea"`
	Where         string         `form:"-"`
	WhereNamedArg map[string]any `form:"-"`
}

func ParsePropertyFromStmt(stmt *sqlite.Stmt) (o Property) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		case "id":
			o.Id = col_val.(int64)
		case "code":
			o.Code = col_val.(string)
		case "address":
			o.Address = col_val.(string)
		case "note":
			o.Note = col_val.(string)
		}
	}
	return
}

func NewProperty(code string) Property {
	o := Property{Where: ` code = :code`, WhereNamedArg: map[string]any{":code": code}}
	output := o.Search()
	if len(output) == 0 {
		o.Code = code
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func GetPropertyByCompositeKeyOrNew(data map[string]interface{}) *Property {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := Property{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM property WHERE  code = :code`, &sqlitex.ExecOptions{
		Named: map[string]any{":code": data["code"]},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = ParsePropertyFromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := NewProperty(data["code"].(string))
		tn.Update(data)
		return &tn
	}
}

func GetProperty(code string) *Property {
	o := Property{
		Code:          code,
		Where:         " code = :code",
		WhereNamedArg: map[string]any{":code": code},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetPropertyByID(id int64) *Property {
	o := Property{
		Id:            id,
		Where:         "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Property) Search() []Property {
	output := []Property{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM property WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := ParsePropertyFromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Property) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "code" {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE property SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Property) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO property(code,address,note) VALUES(:code,:address,:note) ON CONFLICT( code) DO UPDATE SET code=excluded.code,address=excluded.address,note=excluded.note`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":code": o.Code, ":address": o.Address, ":note": o.Note},
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *Property) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM property WHERE  code = :code`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":code": o.Code},
	})
}

func DeletePropertyByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM property WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}

// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"database/sql"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"

	u "github.com/sunshine69/golang-tools/utils"
	_ "modernc.org/sqlite"
)

type Payment struct {
	Id         int64  `db:"id"`
	Account_id int64  `db:"account_id,unique"`
	Tenant     string `db:"tenant"`
	Amount     int64  `db:"amount"`
	Pay_date   string `db:"pay_date,unique"`
	Reference  string `db:"reference"`
	Where      string `form:"-"`
}

func NewPayment(account_id int64, pay_date string) Payment {

	o := Payment{}
	if err := DB.Get(&o, "SELECT * FROM payment WHERE  account_id = ? AND  pay_date = ?", account_id, pay_date); errors.Is(err, sql.ErrNoRows) {
		o.Account_id = account_id
		o.Pay_date = pay_date
		if o.Pay_date == "" {
			o.Pay_date = time.Now().Format(u.TimeISO8601LayOut)
		}
		o.Save()
	}
	// get one and test if exists return as it is
	return o
}

func GetPaymentByCompositeKeyOrNew(data map[string]interface{}) *Payment {
	data = ParseDatetimeFieldOfMapData(data)
	if rows, err := DB.NamedQuery(`SELECT * FROM payment WHERE account_id=:account_id  AND pay_date=:pay_date `, data); err == nil {
		defer rows.Close()
		for rows.Next() {
			tn := Payment{}
			if err = rows.StructScan(&tn); err == nil {
				return &tn
			} else {
				fmt.Fprintf(os.Stderr, "[ERROR] GetPaymentByCompositeKey %s\n", err.Error())
				return nil
			}
		}
		// create new one
		tn := NewPayment(data["account_id"].(int64), data["pay_date"].(string))
		tn.Update(data)
		return &tn
	} else {
		fmt.Fprintf(os.Stderr, "[ERROR] GetPaymentByCompositeKey %s\n", err.Error())
	}
	return nil
}

func GetPayment(account_id int64, pay_date string) *Payment {
	o := Payment{
		Account_id: account_id, Pay_date: pay_date,
		Where: "account_id=:account_id , pay_date=:pay_date "}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetPaymentByID(id int64) *Payment {
	o := Payment{
		Id:    id,
		Where: "id=:id"}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Payment) Search() []Payment {
	output := []Payment{}
	if o.Where == "" {
		o.Where = "pay_date LIKE '%" + o.Pay_date + "%'"
	}
	fmt.Println(o.Where)
	if rows, err := DB.NamedQuery(fmt.Sprintf(`SELECT * FROM payment WHERE %s`, o.Where), o); err == nil {
		defer rows.Close()
		for rows.Next() {
			_t := Payment{}
			if er := rows.StructScan(&_t); er == nil {
				output = append(output, _t)
			} else {
				fmt.Printf("[ERROR] Scan %s\n", er.Error())
				continue
			}
		}
	} else {
		fmt.Printf("[ERROR] NamedQuery %s\n", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Payment) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "account_id" && s != "pay_date" {
			return &s
		}
		return nil
	})
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string { s = s + " = :" + s; return &s })
	updateFieldsStr := strings.Join(updateFields, ",")

	if _, err := DB.NamedExec(`UPDATE payment SET `+updateFieldsStr, data); err != nil {
		return err
	}
	return nil
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Payment) Save() error {
	if res, err := DB.NamedExec(`INSERT INTO payment(account_id,tenant,amount,pay_date,reference) VALUES(:account_id,:tenant,:amount,:pay_date,:reference) ON CONFLICT( account_id,pay_date) DO UPDATE SET account_id=excluded.account_id,tenant=excluded.tenant,amount=excluded.amount,pay_date=excluded.pay_date,reference=excluded.reference`, o); err != nil {
		return err
	} else {
		o.Id, _ = res.LastInsertId()
	}
	return nil
}

// Delete one object
func (o *Payment) Delete() error {
	if res, err := DB.NamedExec(`DELETE FROM payment WHERE account_id=:account_id , pay_date=:pay_date `, o); err != nil {
		return err
	} else {
		r, err := res.RowsAffected()
		if err != nil {
			return err
		}
		if r == 0 {
			return fmt.Errorf("ERROR payment not found")
		}
	}
	return nil
}

func DeletePaymentByID(id int64) error {
	// sqlx bug? If directly use Exec and sql is a pure string it never delete it but still return ok
	// looks like we always need to bind the named query with sqlx - can not parse pure string in
	if res, err := DB.NamedExec(`DELETE FROM payment WHERE id = :id`, map[string]interface{}{"id": id}); err != nil {
		return err
	} else {
		r, err := res.RowsAffected()
		if err != nil {
			return err
		}
		if r == 0 {
			return fmt.Errorf("ERROR payment not found")
		}
	}
	return nil
}

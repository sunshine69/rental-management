// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"context"
	u "github.com/sunshine69/golang-tools/utils"
	"strings"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type Payment struct {
	Id            int64          `db:"id"`
	Account_id    int64          `db:"account_id,unique"`
	Tenant        string         `db:"tenant"`
	Amount        int64          `db:"amount"`
	Pay_date      string         `db:"pay_date,unique"`
	Reference     string         `db:"reference"`
	Where         string         `form:"-"`
	WhereNamedArg map[string]any `form:"-"`
}

func ParsePaymentFromStmt(stmt *sqlite.Stmt) (o Payment) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		case "id":
			o.Id = col_val.(int64)
		case "account_id":
			o.Account_id = col_val.(int64)
		case "tenant":
			o.Tenant = col_val.(string)
		case "amount":
			o.Amount = col_val.(int64)
		case "pay_date":
			o.Pay_date = col_val.(string)
		case "reference":
			o.Reference = col_val.(string)
		}
	}
	return
}

func NewPayment(account_id int64, pay_date string) Payment {
	o := Payment{Where: ` account_id = :account_id AND  pay_date = :pay_date`, WhereNamedArg: map[string]any{":account_id": account_id, ":pay_date": pay_date}}
	output := o.Search()
	if len(output) == 0 {
		o.Account_id = account_id
		o.Pay_date = pay_date
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func GetPaymentByCompositeKeyOrNew(data map[string]interface{}) *Payment {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := Payment{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM payment WHERE  account_id = :account_id AND  pay_date = :pay_date`, &sqlitex.ExecOptions{
		Named: map[string]any{":account_id": data["account_id"], ":pay_date": data["pay_date"]},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = ParsePaymentFromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := NewPayment(data["account_id"].(int64), data["pay_date"].(string))
		tn.Update(data)
		return &tn
	}
}

func GetPayment(account_id int64, pay_date string) *Payment {
	o := Payment{
		Account_id: account_id, Pay_date: pay_date,
		Where:         " account_id = :account_id AND  pay_date = :pay_date",
		WhereNamedArg: map[string]any{":account_id": account_id, ":pay_date": pay_date},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetPaymentByID(id int64) *Payment {
	o := Payment{
		Id:            id,
		Where:         "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Payment) Search() []Payment {
	output := []Payment{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM payment WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := ParsePaymentFromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Payment) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "account_id" && s != "pay_date" {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE payment SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Payment) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO payment(account_id,tenant,amount,pay_date,reference) VALUES(:account_id,:tenant,:amount,:pay_date,:reference) ON CONFLICT( account_id,pay_date) DO UPDATE SET account_id=excluded.account_id,tenant=excluded.tenant,amount=excluded.amount,pay_date=excluded.pay_date,reference=excluded.reference`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":account_id": o.Account_id, ":tenant": o.Tenant, ":amount": o.Amount, ":pay_date": o.Pay_date, ":reference": o.Reference},
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *Payment) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM payment WHERE  account_id = :account_id AND  pay_date = :pay_date`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":account_id": o.Account_id, ":pay_date": o.Pay_date},
	})
}

func DeletePaymentByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM payment WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}

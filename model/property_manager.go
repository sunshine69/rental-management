// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"context"
	u "github.com/sunshine69/golang-tools/utils"
	"strings"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type Property_manager struct {
	Id             int64          `db:"id"`
	First_name     string         `db:"first_name"`
	Last_name      string         `db:"last_name"`
	Address        string         `db:"address"`
	Contact_number string         `db:"contact_number"`
	Email          string         `db:"email,unique"`
	Join_date      string         `db:"join_date"`
	Note           string         `db:"note" form:"Note,ele=textarea"`
	Where          string         `form:"-"`
	WhereNamedArg  map[string]any `form:"-"`
}

func ParseProperty_managerFromStmt(stmt *sqlite.Stmt) (o Property_manager) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		case "id":
			o.Id = col_val.(int64)
		case "first_name":
			o.First_name = col_val.(string)
		case "last_name":
			o.Last_name = col_val.(string)
		case "address":
			o.Address = col_val.(string)
		case "contact_number":
			o.Contact_number = col_val.(string)
		case "email":
			o.Email = col_val.(string)
		case "join_date":
			o.Join_date = col_val.(string)
		case "note":
			o.Note = col_val.(string)
		}
	}
	return
}

func NewProperty_manager(email string) Property_manager {
	o := Property_manager{Where: ` email = :email`, WhereNamedArg: map[string]any{":email": email}}
	output := o.Search()
	if len(output) == 0 {
		o.Email = email
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func GetProperty_managerByCompositeKeyOrNew(data map[string]interface{}) *Property_manager {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := Property_manager{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM property_manager WHERE  email = :email`, &sqlitex.ExecOptions{
		Named: map[string]any{":email": data["email"]},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = ParseProperty_managerFromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := NewProperty_manager(data["email"].(string))
		tn.Update(data)
		return &tn
	}
}

func GetProperty_manager(email string) *Property_manager {
	o := Property_manager{
		Email:         email,
		Where:         " email = :email",
		WhereNamedArg: map[string]any{":email": email},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetProperty_managerByID(id int64) *Property_manager {
	o := Property_manager{
		Id:            id,
		Where:         "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Property_manager) Search() []Property_manager {
	output := []Property_manager{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM property_manager WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := ParseProperty_managerFromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Property_manager) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "email" {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE property_manager SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Property_manager) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO property_manager(first_name,last_name,address,contact_number,email,join_date,note) VALUES(:first_name,:last_name,:address,:contact_number,:email,:join_date,:note) ON CONFLICT( email) DO UPDATE SET first_name=excluded.first_name,last_name=excluded.last_name,address=excluded.address,contact_number=excluded.contact_number,email=excluded.email,join_date=excluded.join_date,note=excluded.note`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":first_name": o.First_name, ":last_name": o.Last_name, ":address": o.Address, ":contact_number": o.Contact_number, ":email": o.Email, ":join_date": o.Join_date, ":note": o.Note},
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *Property_manager) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM property_manager WHERE  email = :email`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":email": o.Email},
	})
}

func DeleteProperty_managerByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM property_manager WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}

// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"context"
	u "github.com/sunshine69/golang-tools/utils"
	"strings"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type Contract struct {
	Id                 int64          `db:"id"`
	Property           string         `db:"property,unique"`
	Property_manager   string         `db:"property_manager"`
	Tenant_main        string         `db:"tenant_main,unique"`
	Tenants            string         `db:"tenants"`
	Start_date         string         `db:"start_date,unique"`
	End_date           string         `db:"end_date"`
	Signed_date        string         `db:"signed_date"`
	Term               string         `db:"term"`
	Rent               int64          `db:"rent"`
	Rent_period        string         `db:"rent_period"`
	Rent_paid_on       string         `db:"rent_paid_on"`
	Water_charged      int64          `db:"water_charged"`
	Document_file_path string         `db:"document_file_path"`
	Url                string         `db:"url"`
	Note               string         `db:"note" form:"Note,ele=textarea"`
	Where              string         `form:"-"`
	WhereNamedArg      map[string]any `form:"-"`
}

func ParseContractFromStmt(stmt *sqlite.Stmt) (o Contract) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		case "id":
			o.Id = col_val.(int64)
		case "property":
			o.Property = col_val.(string)
		case "property_manager":
			o.Property_manager = col_val.(string)
		case "tenant_main":
			o.Tenant_main = col_val.(string)
		case "tenants":
			o.Tenants = col_val.(string)
		case "start_date":
			o.Start_date = col_val.(string)
		case "end_date":
			o.End_date = col_val.(string)
		case "signed_date":
			o.Signed_date = col_val.(string)
		case "term":
			o.Term = col_val.(string)
		case "rent":
			o.Rent = col_val.(int64)
		case "rent_period":
			o.Rent_period = col_val.(string)
		case "rent_paid_on":
			o.Rent_paid_on = col_val.(string)
		case "water_charged":
			o.Water_charged = col_val.(int64)
		case "document_file_path":
			o.Document_file_path = col_val.(string)
		case "url":
			o.Url = col_val.(string)
		case "note":
			o.Note = col_val.(string)
		}
	}
	return
}

func NewContract(property string, start_date string, tenant_main string) Contract {
	o := Contract{Where: ` property = :property AND  start_date = :start_date AND  tenant_main = :tenant_main`, WhereNamedArg: map[string]any{":property": property, ":start_date": start_date, ":tenant_main": tenant_main}}
	output := o.Search()
	if len(output) == 0 {
		o.Property = property
		o.Start_date = start_date
		o.Tenant_main = tenant_main
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func GetContractByCompositeKeyOrNew(data map[string]interface{}) *Contract {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := Contract{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM contract WHERE  property = :property AND  start_date = :start_date AND  tenant_main = :tenant_main`, &sqlitex.ExecOptions{
		Named: map[string]any{":property": data["property"], ":start_date": data["start_date"], ":tenant_main": data["tenant_main"]},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = ParseContractFromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := NewContract(data["property"].(string), data["start_date"].(string), data["tenant_main"].(string))
		tn.Update(data)
		return &tn
	}
}

func GetContract(property string, start_date string, tenant_main string) *Contract {
	o := Contract{
		Property: property, Start_date: start_date, Tenant_main: tenant_main,
		Where:         " property = :property AND  start_date = :start_date AND  tenant_main = :tenant_main",
		WhereNamedArg: map[string]any{":property": property, ":start_date": start_date, ":tenant_main": tenant_main},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetContractByID(id int64) *Contract {
	o := Contract{
		Id:            id,
		Where:         "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Contract) Search() []Contract {
	output := []Contract{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM contract WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := ParseContractFromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Contract) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "property" && s != "start_date" && s != "tenant_main" {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE contract SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Contract) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO contract(property,property_manager,tenant_main,tenants,start_date,end_date,signed_date,term,rent,rent_period,rent_paid_on,water_charged,document_file_path,url,note) VALUES(:property,:property_manager,:tenant_main,:tenants,:start_date,:end_date,:signed_date,:term,:rent,:rent_period,:rent_paid_on,:water_charged,:document_file_path,:url,:note) ON CONFLICT( property,start_date,tenant_main) DO UPDATE SET property=excluded.property,property_manager=excluded.property_manager,tenant_main=excluded.tenant_main,tenants=excluded.tenants,start_date=excluded.start_date,end_date=excluded.end_date,signed_date=excluded.signed_date,term=excluded.term,rent=excluded.rent,rent_period=excluded.rent_period,rent_paid_on=excluded.rent_paid_on,water_charged=excluded.water_charged,document_file_path=excluded.document_file_path,url=excluded.url,note=excluded.note`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":property": o.Property, ":property_manager": o.Property_manager, ":tenant_main": o.Tenant_main, ":tenants": o.Tenants, ":start_date": o.Start_date, ":end_date": o.End_date, ":signed_date": o.Signed_date, ":term": o.Term, ":rent": o.Rent, ":rent_period": o.Rent_period, ":rent_paid_on": o.Rent_paid_on, ":water_charged": o.Water_charged, ":document_file_path": o.Document_file_path, ":url": o.Url, ":note": o.Note},
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *Contract) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM contract WHERE  property = :property AND  start_date = :start_date AND  tenant_main = :tenant_main`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":property": o.Property, ":start_date": o.Start_date, ":tenant_main": o.Tenant_main},
	})
}

func DeleteContractByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM contract WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}

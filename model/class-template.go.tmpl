// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"strings"
	"context"
	{{- range $idx, $f := .fieldsList }}
	{{- if contains $f "date" }}
	"time"
	{{break}}
	{{- end }}
	{{- end }}
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
	u "github.com/sunshine69/golang-tools/utils"
)

type {{ .typename | title }} struct {
	{{- range $f := .fieldsList }}
	{{ $f | title }} {{ index $.fields $f }} `db:"{{$f}}{{if index $.uniqueFieldsMap $f}},unique{{end}}"{{if eq $f "note"}} form:"Note,ele=textarea"{{end}}`
	{{- end }}
	Where          string          `form:"-"`
	WhereNamedArg  map[string]any  `form:"-"`
}

func Parse{{ .typename | title }}FromStmt(stmt *sqlite.Stmt) (o {{ .typename | title }}) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		{{- range $f := .fieldsList }}
		case "{{$f}}":
			o.{{$f|title}} = col_val.({{ index $.fields $f }})
			{{- if contains $f "date" }}
			if o.{{$f|title}} == "" {
				o.{{$f|title}} = time.Now().Format(u.TimeISO8601LayOut)
			}
			{{- end }}
		{{- end }}
		}
	}
	return
}


func New{{ .typename | title }}( {{- range $idx, $f := .uniqueFields -}}{{- $f }} {{ index $.uniqueFieldsMap $f }} {{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} ) {{ .typename | title }} {
	o := {{ .typename | title }}{ Where: `{{.query_new}}`, WhereNamedArg: map[string]any{ {{- range $idx, $f := .uniqueFields -}}":{{$f}}": {{$f}} {{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} } }
	output := o.Search()
	if len(output) == 0 {
		{{- range $idx, $f := .uniqueFields }}
		o.{{$f|title}} = {{$f}}
		{{- end }}
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func Get{{.typename|title}}ByCompositeKeyOrNew(data map[string]interface{}) *{{.typename|title}} {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := {{ .typename | title }}{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM {{ .typename }} WHERE {{.query_new}}`, &sqlitex.ExecOptions{
		Named: map[string]any{ {{- range $idx, $f := .uniqueFields -}}":{{$f}}": data["{{$f}}"] {{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} },
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = Parse{{ .typename | title }}FromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := New{{ .typename | title }}( {{- range $idx, $f := .uniqueFields -}}data["{{$f}}"].({{index $.uniqueFieldsMap $f}}){{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} )
		tn.Update(data)
		return &tn
	}
}

func Get{{.typename|title}}({{range $idx, $f := .uniqueFields}}{{$f}} {{ index $.uniqueFieldsMap $f }}{{if ne $idx (add ($.uniqueFields|len) -1)}}, {{end}}{{end}}) *{{.typename|title}} {
	o := {{ .typename|title }}{
		{{range $idx, $f := .uniqueFields}}{{$f|title}}: {{$f}} {{if ne $idx (add ($.uniqueFields|len) -1)}},{{end}}{{end}},
		Where: "{{.query_new}}",
		WhereNamedArg: map[string]any{ {{- range $idx, $f := .uniqueFields -}}":{{$f}}": {{$f}} {{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} },
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func Get{{.typename|title}}ByID(id int64) *{{.typename|title}} {
	o := {{ .typename|title  }}{
		Id:    id,
		Where: "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *{{.typename|title}}) Search() []{{.typename|title}} {
	output := []{{ .typename|title  }}{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM {{.typename}} WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := Parse{{ .typename|title  }}FromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *{{.typename|title}}) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && {{- range $idx, $f := .uniqueFields -}}s != "{{$f}}" {{ if ne $idx (add ($.uniqueFields|len) -1) }} && {{ end }} {{- end -}} {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE {{.typename}} SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}


// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *{{.typename|title}}) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO {{.typename}}({{range $idx, $f := .fieldsList}}{{if ne $f "id"}}{{$f}}{{end}}{{if ne $f "id"}}{{if ne $idx (add ($.fieldsList|len) -1)}},{{end}}{{end}}{{end}}) VALUES({{range $idx, $f := .fieldsList}}{{if ne $f "id"}}:{{$f}}{{end}}{{if ne $f "id"}}{{if ne $idx (add ($.fieldsList|len) -1)}},{{end}}{{end}}{{end}}) ON CONFLICT( {{range $idx, $f := .uniqueFields}}{{$f}}{{if ne $idx (add ($.uniqueFields|len) -1)}},{{end}}{{end}}) DO UPDATE SET {{range $idx, $f := .fieldsList}}{{if ne $f "id"}}{{$f}}=excluded.{{$f}}{{end}}{{if ne $f "id"}}{{if ne $idx (add ($.fieldsList|len) -1)}},{{end}}{{end}}{{end}}`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{ {{- range $idx, $f := .fieldsList -}}{{if ne $f "id"}}":{{$f}}": o.{{$f|title}} {{ if ne $idx (add ($.fieldsList|len) -1) }},{{end}}{{end}}{{end}} },
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *{{.typename|title}}) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM {{.typename}} WHERE {{.query_new}}`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{ {{- range $idx, $f := .uniqueFields -}}":{{$f}}": o.{{$f|title}} {{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} },
	})
}

func Delete{{.typename|title}}ByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM {{.typename}} WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}

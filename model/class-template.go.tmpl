// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl 
package model

import (
	"database/sql"
	"errors"
	"fmt"
	{{- range $idx, $f := .fieldsList }}
	{{- if contains $f "date" }}
	"time"	
	{{- end }}
	{{- end }}
	_ "github.com/mutecomm/go-sqlcipher/v4"
)

type {{ .typename | title }} struct {
	{{ range $f, $gt := .fields -}}
	 {{ $f | title }} {{ $gt }} `db:"{{ $f }}"`
	{{ end }}
	Where string 
}

func New{{ .typename | title }}( {{- range $idx, $f := .uniqueFields -}}{{- $f }} {{ index $.uniqueFieldsMap $f }} {{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} ) {{ .typename | title }} {

	o := {{ .typename | title }}{}
	if err := DB.Get(&o, "{{ .query_new }}", {{- range $idx, $f := .uniqueFields -}}{{- $f }} {{ if ne $idx (add ($.uniqueFields|len) -1) }},{{ end }} {{- end -}} ); errors.Is(err, sql.ErrNoRows) {
		{{- range $idx, $f := .uniqueFields }}		
		o.{{ $f|title }} = {{ $f }}
		{{- end }}
		{{- range $idx, $f := .fieldsList }}
		{{- if contains $f "date" }}
		if o.{{ $f|title }} == 0 {
			o.{{ $f|title }} = time.Now().Unix()
		}		
		{{- end }}
		{{- end }}
		o.Save()
	}
	// get one and test if exists return as it is
	return o	
}

// Search func
func (o *{{.typename|title}}) Search() []{{.typename|title}} {
	output := []{{.typename|title}}{}
	if rows, err := DB.NamedQuery(fmt.Sprintf(`SELECT * FROM {{.typename}} WHERE %s`, o.Where), o); err == nil {
		for rows.Next() {
			_t := {{.typename|title}}{}
			if er := rows.StructScan(&_t); er == nil {
				output = append(output, _t)
			} else {
				fmt.Printf("[ERROR] Scan %s\n", er.Error())
				continue
			}
		}
	} else {
		fmt.Printf("[ERROR] NamedQuery %s\n", err.Error())
	}
	return output
}

// Save existing object which is saved it into db 
func (o *{{.typename|title}}) Save() {
	if res, err := DB.NamedExec(`INSERT INTO {{.typename}}({{range $idx, $f := .fieldsList}}{{$f}}{{if ne $idx (add ($.fieldsList|len) -1)}},{{end}}{{end}} ) VALUES({{range $idx, $f := .fieldsList}}:{{$f}}{{if ne $idx (add ($.fieldsList|len) -1)}},{{end}}{{end}} ) ON CONFLICT({{range $idx, $f := .uniqueFields}}{{$f}}{{if ne $idx (add ($.uniqueFields|len) -1)}},{{end}}{{end}}) DO UPDATE SET {{range $idx, $f := .fieldsList}}{{$f}}=excluded.{{$f}}{{if ne $idx (add ($.fieldsList|len) -1)}},{{end}}{{end}}`, o); err != nil {
		panic(err.Error())
	} else {
		o.Id, _ = res.LastInsertId()
	}
}

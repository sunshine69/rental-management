// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"context"
	u "github.com/sunshine69/golang-tools/utils"
	"strings"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type Tenant struct {
	Id             int64          `db:"id"`
	First_name     string         `db:"first_name"`
	Last_name      string         `db:"last_name"`
	Address        string         `db:"address"`
	Contact_number string         `db:"contact_number"`
	Email          string         `db:"email,unique"`
	Join_date      string         `db:"join_date"`
	Note           string         `db:"note" form:"Note,ele=textarea"`
	Where          string         `form:"-"`
	WhereNamedArg  map[string]any `form:"-"`
}

func ParseTenantFromStmt(stmt *sqlite.Stmt) (o Tenant) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		case "id":
			o.Id = col_val.(int64)
		case "first_name":
			o.First_name = col_val.(string)
		case "last_name":
			o.Last_name = col_val.(string)
		case "address":
			o.Address = col_val.(string)
		case "contact_number":
			o.Contact_number = col_val.(string)
		case "email":
			o.Email = col_val.(string)
		case "join_date":
			o.Join_date = col_val.(string)
		case "note":
			o.Note = col_val.(string)
		}
	}
	return
}

func NewTenant(email string) Tenant {
	o := Tenant{Where: ` email = :email`, WhereNamedArg: map[string]any{":email": email}}
	output := o.Search()
	if len(output) == 0 {
		o.Email = email
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func GetTenantByCompositeKeyOrNew(data map[string]interface{}) *Tenant {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := Tenant{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM tenant WHERE  email = :email`, &sqlitex.ExecOptions{
		Named: map[string]any{":email": data["email"]},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = ParseTenantFromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := NewTenant(data["email"].(string))
		tn.Update(data)
		return &tn
	}
}

func GetTenant(email string) *Tenant {
	o := Tenant{
		Email:         email,
		Where:         " email = :email",
		WhereNamedArg: map[string]any{":email": email},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetTenantByID(id int64) *Tenant {
	o := Tenant{
		Id:            id,
		Where:         "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Tenant) Search() []Tenant {
	output := []Tenant{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM tenant WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := ParseTenantFromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Tenant) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "email" {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE tenant SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Tenant) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO tenant(first_name,last_name,address,contact_number,email,join_date,note) VALUES(:first_name,:last_name,:address,:contact_number,:email,:join_date,:note) ON CONFLICT( email) DO UPDATE SET first_name=excluded.first_name,last_name=excluded.last_name,address=excluded.address,contact_number=excluded.contact_number,email=excluded.email,join_date=excluded.join_date,note=excluded.note`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":first_name": o.First_name, ":last_name": o.Last_name, ":address": o.Address, ":contact_number": o.Contact_number, ":email": o.Email, ":join_date": o.Join_date, ":note": o.Note},
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *Tenant) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM tenant WHERE  email = :email`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":email": o.Email},
	})
}

func DeleteTenantByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM tenant WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}

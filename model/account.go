// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"context"
	u "github.com/sunshine69/golang-tools/utils"
	"strings"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type Account struct {
	Id            int64          `db:"id"`
	Balance       int64          `db:"balance"`
	Contract_id   int64          `db:"contract_id,unique"`
	Tenant_main   string         `db:"tenant_main"`
	Note          string         `db:"note" form:"Note,ele=textarea"`
	Where         string         `form:"-"`
	WhereNamedArg map[string]any `form:"-"`
}

func ParseAccountFromStmt(stmt *sqlite.Stmt) (o Account) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		case "id":
			o.Id = col_val.(int64)
		case "balance":
			o.Balance = col_val.(int64)
		case "contract_id":
			o.Contract_id = col_val.(int64)
		case "tenant_main":
			o.Tenant_main = col_val.(string)
		case "note":
			o.Note = col_val.(string)
		}
	}
	return
}

func NewAccount(contract_id int64) Account {
	o := Account{Where: ` contract_id = :contract_id`, WhereNamedArg: map[string]any{":contract_id": contract_id}}
	output := o.Search()
	if len(output) == 0 {
		o.Contract_id = contract_id
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func GetAccountByCompositeKeyOrNew(data map[string]interface{}) *Account {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := Account{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM account WHERE  contract_id = :contract_id`, &sqlitex.ExecOptions{
		Named: map[string]any{":contract_id": data["contract_id"]},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = ParseAccountFromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := NewAccount(data["contract_id"].(int64))
		tn.Update(data)
		return &tn
	}
}

func GetAccount(contract_id int64) *Account {
	o := Account{
		Contract_id:   contract_id,
		Where:         " contract_id = :contract_id",
		WhereNamedArg: map[string]any{":contract_id": contract_id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetAccountByID(id int64) *Account {
	o := Account{
		Id:            id,
		Where:         "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Account) Search() []Account {
	output := []Account{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM tenant WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := ParseAccountFromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Account) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "contract_id" {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE account SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Account) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO account(balance,contract_id,tenant_main,note) VALUES(:balance,:contract_id,:tenant_main,:note) ON CONFLICT( contract_id) DO UPDATE SET balance=excluded.balance,contract_id=excluded.contract_id,tenant_main=excluded.tenant_main,note=excluded.note`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":id": o.Id, ":balance": o.Balance, ":contract_id": o.Contract_id, ":tenant_main": o.Tenant_main, ":note": o.Note},
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *Account) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM account WHERE  contract_id = :contract_id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":contract_id": o.Contract_id},
	})
}

func DeleteAccountByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM account WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}

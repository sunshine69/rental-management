// Generated by model-gen tool. Do not edit but rather edit the template in utils/class-template.go.tmpl
package model

import (
	"context"
	u "github.com/sunshine69/golang-tools/utils"
	"strings"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type Maintenance_request struct {
	Id            int64          `db:"id"`
	Request_date  string         `db:"request_date,unique"`
	Type          string         `db:"type"`
	Status        string         `db:"status"`
	Cost          int64          `db:"cost"`
	Invoice_id    int64          `db:"invoice_id"`
	Contract_id   int64          `db:"contract_id,unique"`
	Where         string         `form:"-"`
	WhereNamedArg map[string]any `form:"-"`
}

func ParseMaintenance_requestFromStmt(stmt *sqlite.Stmt) (o Maintenance_request) {
	for idx := 0; idx < stmt.ColumnCount(); idx++ {
		col_name, col_val, _ := GetSqliteCol(stmt, idx)
		switch col_name {
		case "id":
			o.Id = col_val.(int64)
		case "request_date":
			o.Request_date = col_val.(string)
		case "type":
			o.Type = col_val.(string)
		case "status":
			o.Status = col_val.(string)
		case "cost":
			o.Cost = col_val.(int64)
		case "invoice_id":
			o.Invoice_id = col_val.(int64)
		case "contract_id":
			o.Contract_id = col_val.(int64)
		}
	}
	return
}

func NewMaintenance_request(contract_id int64, request_date string) Maintenance_request {
	o := Maintenance_request{Where: ` contract_id = :contract_id AND  request_date = :request_date`, WhereNamedArg: map[string]any{":contract_id": contract_id, ":request_date": request_date}}
	output := o.Search()
	if len(output) == 0 {
		o.Contract_id = contract_id
		o.Request_date = request_date
		o.Save()
	} else {
		o = output[0]
	}
	return o
}

func GetMaintenance_requestByCompositeKeyOrNew(data map[string]interface{}) *Maintenance_request {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	t := Maintenance_request{}
	data = ParseDatetimeFieldOfMapData(data)
	err := sqlitex.Execute(DB, `SELECT * FROM maintenance_request WHERE  contract_id = :contract_id AND  request_date = :request_date`, &sqlitex.ExecOptions{
		Named: map[string]any{":contract_id": data["contract_id"], ":request_date": data["request_date"]},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t = ParseMaintenance_requestFromStmt(stmt)
			return nil
		},
	})
	if err == nil && t.Id != 0 {
		return &t
	} else {
		// create new one
		tn := NewMaintenance_request(data["contract_id"].(int64), data["request_date"].(string))
		tn.Update(data)
		return &tn
	}
}

func GetMaintenance_request(contract_id int64, request_date string) *Maintenance_request {
	o := Maintenance_request{
		Contract_id: contract_id, Request_date: request_date,
		Where:         " contract_id = :contract_id AND  request_date = :request_date",
		WhereNamedArg: map[string]any{":contract_id": contract_id, ":request_date": request_date},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

func GetMaintenance_requestByID(id int64) *Maintenance_request {
	o := Maintenance_request{
		Id:            id,
		Where:         "id=:id",
		WhereNamedArg: map[string]any{":id": id},
	}
	if r := o.Search(); len(r) > 0 {
		return &r[0]
	} else {
		return nil
	}
}

// Search func
func (o *Maintenance_request) Search() []Maintenance_request {
	output := []Maintenance_request{}
	if o.Where == "" {
		o.Where = "true"
		if len(o.WhereNamedArg) == 0 {
			o.WhereNamedArg = map[string]any{}
		}
	}
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	err := sqlitex.Execute(DB, "SELECT * FROM maintenance_request WHERE "+o.Where, &sqlitex.ExecOptions{
		Named: o.WhereNamedArg,
		ResultFunc: func(stmt *sqlite.Stmt) error {
			t := ParseMaintenance_requestFromStmt(stmt)
			output = append(output, t)
			return nil
		},
	})
	if err != nil {
		println("[ERROR] ", err.Error())
	}
	return output
}

// Save new object which is saved it into db
func (o *Maintenance_request) Update(data map[string]interface{}) error {
	fields := u.MapKeysToSlice(data)
	fieldsWithoutKey := u.SliceMap(fields, func(s string) *string {
		if s != "id" && s != "contract_id" && s != "request_date" {
			return &s
		}
		return nil
	})
	namedArgs := map[string]any{}
	updateFields := u.SliceMap(fieldsWithoutKey, func(s string) *string {
		s = s + " = :" + s
		namedArgs[":"+s] = data[s]
		return &s
	})
	updateFieldsStr := strings.Join(updateFields, ",")

	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	return sqlitex.Execute(DB, `UPDATE maintenance_request SET `+updateFieldsStr, &sqlitex.ExecOptions{
		Named: namedArgs,
	})
}

// Save existing object which is saved it into db. Note that this will update all fields. If you only update some fields then better use the Update func above
func (o *Maintenance_request) Save() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `INSERT INTO maintenance_request(request_date,type,status,cost,invoice_id,contract_id) VALUES(:request_date,:type,:status,:cost,:invoice_id,:contract_id) ON CONFLICT( contract_id,request_date) DO UPDATE SET request_date=excluded.request_date,type=excluded.type,status=excluded.status,cost=excluded.cost,invoice_id=excluded.invoice_id,contract_id=excluded.contract_id`
	err := sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":request_date": o.Request_date, ":type": o.Type, ":status": o.Status, ":cost": o.Cost, ":invoice_id": o.Invoice_id, ":contract_id": o.Contract_id},
	})
	if err != nil {
		return err
	}
	if DB.Changes() > 0 {
		o.Id = DB.LastInsertRowID()
	}
	return nil
}

// Delete one object
func (o *Maintenance_request) Delete() error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM maintenance_request WHERE  contract_id = :contract_id AND  request_date = :request_date`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{":contract_id": o.Contract_id, ":request_date": o.Request_date},
	})
}

func DeleteMaintenance_requestByID(id int64) error {
	DB := u.Must(DbPool.Take(context.TODO()))
	defer DbPool.Put(DB)
	sqlstr := `DELETE FROM maintenance_request WHERE id = :id`
	return sqlitex.Execute(DB, sqlstr, &sqlitex.ExecOptions{
		Named: map[string]any{
			":id": id,
		},
	})
}
